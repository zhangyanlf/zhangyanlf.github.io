{"meta":{"title":"zhangyanlf","subtitle":"iOS、Android、React/React-Native","description":"全栈进阶之路","author":"zhangyanlf","url":"https://zhangyanlf.top"},"pages":[{"title":"about me","date":"2017-05-11T16:00:00.000Z","updated":"2017-05-12T03:46:24.000Z","comments":true,"path":"about/index.html","permalink":"https://zhangyanlf.top/about/index.html","excerpt":"","text":"\u001a\u001a\u001azhangyanlf \u001a\u001a\u001a\u001a\u001a现在的我：职业 iOS / RN开发者业余 Java 开发者业余篮球爱好者 也许您在这里能看到的只是中国千千万万工科生之中最普通的一员所写下的最蹩足的文字但我相信它们真实地记载了我的生活，我的成长- 正如伯乐得见绝世好马，子期终遇伯牙佳音良驹美景， 高山流水我真心希望 您就是 我的伯乐，我的子期 您可以在新浪微博，Twitter或者Github上找到我。"}],"posts":[{"title":"隐私政策","slug":"隐私政策","date":"2018-10-28T16:00:00.000Z","updated":"2018-10-31T09:23:43.000Z","comments":true,"path":"2018/10/29/隐私政策/","link":"","permalink":"https://zhangyanlf.top/2018/10/29/隐私政策/","excerpt":"","text":"本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。1. 适用范围(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。您了解并同意，以下信息不适用本隐私权政策：(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2. 信息使用(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：(a) 经您事先同意，向第三方披露；(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。 6. 信息安全(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对 7. 本隐私政策的更改(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。 方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。 已同步至本人博客","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://zhangyanlf.top/tags/iOS/"}]},{"title":"iOS Storyboard  使用技巧分享","slug":"iOS Storyboard  技巧","date":"2018-08-15T16:00:00.000Z","updated":"2018-08-16T07:09:12.000Z","comments":true,"path":"2018/08/16/iOS Storyboard  技巧/","link":"","permalink":"https://zhangyanlf.top/2018/08/16/iOS Storyboard  技巧/","excerpt":"","text":"最近一段时间一直在忙项目，好久没有更新博客了，今天给大家分享一个iOS开发者使用Storyboard 设置属性的小技巧（将属性设置直接添加到Storyboard面板设置及实时查看效果）： 下面以UIVIew设置圆角及阴影效果展示具体效果 首先创建Swift file 对UIView进行扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354extension UIView &#123; @IBInspectable var cornerRadius : CGFloat &#123; get &#123; return layer.cornerRadius &#125; set &#123; layer.cornerRadius = newValue &#125; &#125; //阴影圆角 @IBInspectable var shadowRadius : CGFloat &#123; get &#123; return layer.shadowRadius &#125; set &#123; layer.shadowRadius = newValue &#125; &#125; //阴影偏移 @IBInspectable var shadowOffset : CGSize &#123; get &#123; return layer.shadowOffset &#125; set &#123; layer.shadowOffset = newValue &#125; &#125; //阴影颜色 @IBInspectable var shadowColor : UIColor? &#123; get &#123; return layer.shadowColor != nil ? UIColor(cgColor: layer.shadowColor!) : nil &#125; set &#123; layer.shadowColor = newValue?.cgColor &#125; &#125; //阴影透明度 @IBInspectable var shadowOpacity : Float &#123; get &#123; return layer.shadowOpacity &#125; set &#123; layer.shadowOpacity = newValue &#125; &#125; @IBInspectable 可以使设置的属性直接显示在Storyboard面板中，如图： 属性设置可以及时在Storyboard中看到效果(当前设置View的Class设置为ArcView)1234@IBDesignable class ArcView: UIView &#123; &#125; @IBDesignable 在Storyboard中及时看到效果(阴影效果) 这种方式可以在开发中节省不少代码量，看到的小伙伴们赶紧去试试效果，后期有好的技巧还会在博客中持续更新，小伙伴可以多多关注。 也可以去GitHUb查看使用案例 已同步至本人博客","categories":[],"tags":[{"name":"iOS Swift","slug":"iOS-Swift","permalink":"https://zhangyanlf.top/tags/iOS-Swift/"}]},{"title":"React-Native封装Tabbar 实现中间按钮溢出效果(Android/iOS)","slug":"React-Native封装Tabbar 实现中间按钮溢出效果(Android_iOS)","date":"2018-02-04T16:00:00.000Z","updated":"2018-02-05T02:13:14.000Z","comments":true,"path":"2018/02/05/React-Native封装Tabbar 实现中间按钮溢出效果(Android_iOS)/","link":"","permalink":"https://zhangyanlf.top/2018/02/05/React-Native封装Tabbar 实现中间按钮溢出效果(Android_iOS)/","excerpt":"","text":"以前写过一篇文章是基于react-native-tab-navigator 封装Tabbar，由于RN版本的不断更新，react-navigation，自17年1月开源以来就备受关注，Fb推荐使用库，并且在React Native0.44中已将Navigator删除。本文将以 react-navigation – 1.0.0-beta.27 / React-Native – 0.52.2 封装实现导航栏的溢出效果！RN实现按钮凸出效果，在iOS移动端可以根据调整按钮上下的布局就能实现溢出效果的样式，Android端不支持溢出效果，所有要兼容Android端，则需要使用一个更高的容器试图支持一个大图标按钮(使用绝对布局实现该效果)!NEXT：实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * Created by zhangyanlf on 2018/2/2. */import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, Platform, StyleSheet, Text, View, TouchableOpacity, NativeModules, ImageBackground, DeviceEventEmitter&#125; from &apos;react-native&apos;;export default class Tab extends Component &#123; renderItem = (route, index) =&gt; &#123; const &#123; navigation, jumpToIndex, &#125; = this.props; const focused = index === navigation.state.index; const color = focused ? this.props.activeTintColor : this.props.inactiveTintColor; let TabScene = &#123; focused:focused, route:route, tintColor:color &#125;; if(index === 2)&#123; return (&lt;View key=&#123;route.key&#125; style=&#123;[styles.tabItem,&#123;backgroundColor:&apos;transparent&apos;&#125;]&#125;&gt; &lt;/View&gt; ); &#125; return ( &lt;TouchableOpacity key=&#123;route.key&#125; style=&#123;styles.tabItem&#125; onPress=&#123;() =&gt; jumpToIndex(index)&#125; &gt; &lt;View style=&#123;styles.tabItem&#125;&gt; &#123;this.props.renderIcon(TabScene)&#125; &lt;Text style=&#123;&#123; ...styles.tabText,marginTop:SCALE(10),color &#125;&#125;&gt;&#123;this.props.getLabel(TabScene)&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125;; render()&#123; const &#123;navigation,jumpToIndex&#125; = this.props; const &#123;routes,&#125; = navigation.state; const focused = 2 === navigation.state.index; const color = focused ? this.props.activeTintColor : this.props.inactiveTintColor; let TabScene = &#123; focused:focused, route:routes[2], tintColor:color &#125;; return (&lt;View style=&#123;&#123;width:WIDTH&#125;&#125;&gt; &lt;View style=&#123;styles.tab&#125;&gt; &#123;routes &amp;&amp; routes.map((route,index) =&gt; this.renderItem(route, index))&#125; &lt;/View&gt; &#123;/*设置中间按钮凸出样式 使用绝对定位*/&#125; &lt;TouchableOpacity key=&#123;&quot;centerView&quot;&#125; style=&#123;[styles.tabItem,&#123;position:&apos;absolute&apos;,bottom:0,left:(WIDTH-SCALE(100))/2,right:WIDTH-SCALE(100),height:SCALE(120)&#125;]&#125; onPress=&#123;() =&gt; jumpToIndex(2)&#125;&gt; &lt;View style=&#123;styles.tabItem&#125;&gt; &#123;this.props.renderIcon(TabScene)&#125; &lt;Text style=&#123;&#123; ...styles.tabText,marginTop:SCALE(10),color &#125;&#125;&gt;&#123;this.props.getLabel(TabScene)&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt;); &#125;&#125;const styles = &#123; tab:&#123; width:WIDTH, backgroundColor:&apos;transparent&apos;, flexDirection:&apos;row&apos;, justifyContent:&apos;space-around&apos;, alignItems:&apos;flex-end&apos; &#125;, tabItem:&#123; height:SCALE(80), width:SCALE(100), alignItems:&apos;center&apos;, justifyContent:&apos;center&apos; &#125;, tabText:&#123; marginTop:SCALE(13), fontSize:FONT(10), color:&apos;#7b7b7b&apos; &#125;, tabTextChoose:&#123; color:&apos;#f3474b&apos; &#125;, tabImage:&#123; width:SCALE(42), height:SCALE(42), &#125;,&#125;; 效果图展示： 想要了解 react-navigation 如何使用也可以查看我的上一篇文章react-navigation使用技巧,也可以查看react-navigation 中文翻译： https://www.reactnavigation.org.cn。PS: 运用 react-navigation 是问题记录 （遇到的问题后续还会持续更新）1.Android 导航栏文字居中效果node_modules – react-navigation – src – views – Header – Header.js 修改368行 将 alignItems: Platform.OS === ‘ios’ ? ‘center’ : ‘flex-start’ 改为 ‘center’即可12345678title: &#123; bottom: 0, left: TITLE_OFFSET, right: TITLE_OFFSET, top: 0, position: &apos;absolute&apos;, alignItems: &apos;center&apos;//Platform.OS === &apos;ios&apos; ? &apos;center&apos; : &apos;flex-start&apos;, &#125;","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"react-navigation使用技巧","slug":"react-navigation使用技巧","date":"2017-11-06T16:00:00.000Z","updated":"2017-12-22T07:19:46.000Z","comments":true,"path":"2017/11/07/react-navigation使用技巧/","link":"","permalink":"https://zhangyanlf.top/2017/11/07/react-navigation使用技巧/","excerpt":"","text":"本文是基于最新的react-navigation^1.0.0-beta.13来书写的。 如果遇到什么问题可以在评论区回复，或者加QQ群397885169讨论: 识兔，一款用来识别图片的开源项目，里面有很多知识点，看看会对你学习RN有很大帮助ReactNavigationDemo什么是react-navigation?react-native从开源至今，一直存在几个无法解决的毛病，偶尔就会复发让人隐隐作痛，提醒你用的不是原生，其中包括列表的复用问题，导航跳转不流畅的问题等等。终于facebook坐不住了，在前一段时间开始推荐使用react-navigation，并且在0.44发布的时将之前一直存在的Navigator废弃了。react-navigation是致力于解决导航卡顿，数据传递，Tabbar和navigator布局，支持redux。虽然现在功能还不完善，但基本是可以在项目中推荐使用的。 属性 react-navigation分为三个部分。 StackNavigator类似顶部导航条，用来跳转页面和传递参数。 TabNavigator类似底部标签栏，用来区分模块。 DrawerNavigator抽屉，类似从App左侧滑出一个页面，在这里不做讲解。下面会分开讲解官网提供的配置方法，但顺序可能会官网不一样。 screenProps 之前是没有介绍这个属性的，但经过这么久发现，很多人都不知道这个属性，不知道它能干嘛，在这里我就简单的介绍下 123456789101112131415// 假设App就是项目中的入口文件，如果还不知道，可以看下Demo，在这里我将主题色通过screenProps属性修改成&apos;red&apos;&lt;App screenProps=&#123;&#123;themeColor:&apos;red&apos;&#125;&#125;&gt;// 在页面中就可以通过screenProps来直接改变了，这个在Demo中的Test2里面static navigationOptions = (&#123;navigation,screenProps&#125;) =&gt; (&#123; // 这里面的属性和App.js的navigationOptions是一样的。 headerStyle:&#123;backgroundColor:screenProps? screenProps.themeColor: &apos;#4ECBFC&apos;&#125;, )&#125;) StackNavigator 基础用法/属性介绍123456789101112131415const MyApp = StackNavigator(&#123; // 对应界面名称 MyTab: &#123; screen: MyTab, &#125;, Detail: &#123; screen: Detail, navigationOptions:&#123; headerTitle:&apos;详情&apos;, headerBackTitle:null, &#125; &#125;,&#125;, &#123; headerMode: &apos;screen&apos;,&#125;); 导航配置iscreen：对应界面名称，需要填入import之后的页面。 navigationOptions：配置StackNavigator的一些属性。 title：标题，如果设置了这个导航栏和标签栏的title就会变成一样的，所以不推荐使用这个方法。 header：可以设置一些导航的属性，当然如果想隐藏顶部导航条只要将这个属性设置为null就可以了 headerTitle：设置导航栏标题，推荐用这个方法。 headerBackTitle：设置跳转页面左侧返回箭头后面的文字，默认是上一个页面的标题。可以自定义，也可以设置为null headerTruncatedBackTitle：设置当上个页面标题不符合返回箭头后的文字时，默认改成”返回”。（上个页面的标题过长，导致显示不下，所以改成了短一些的。） headerRight：设置导航条右侧。可以是按钮或者其他。 headerLeft：设置导航条左侧。可以是按钮或者其他。 headerStyle：设置导航条的样式。背景色，宽高等。如果想去掉安卓导航条底部阴影可以添加elevation: 0，iOS下用shadowOpacity: 0。 headerTitleStyle：设置导航条文字样式。安卓上如果要设置文字居中，只要添加alignSelf:’center’就可以了。在安卓上会遇到，如果左边有返回箭头导致文字还是没有居中的问题，最简单的解决思路就是在右边也放置一个空的按钮。 headerBackTitleStyle：设置导航条返回文字样式。 headerTintColor：设置导航栏文字颜色。总感觉和上面重叠了。 headerPressColorAndroid：安卓独有的设置颜色纹理，需要安卓版本大于5.0 gesturesEnabled：是否支持滑动返回收拾，iOS默认支持，安卓默认关闭 gestureResponseDistance：对象覆盖触摸从屏幕边缘开始的距离，以识别手势。 它需要以下属性： horizontal - number - 水平方向的距离 默认为25。 vertical - number - 垂直方向的距离 默认为135。12// 设置滑动返回的距离gestureResponseDistance:&#123;horizontal:300&#125;, 注：beta13新出的东西，挺有意思，以后可以手动控制返回了 导航视觉效果mode：定义跳转风格。 card：使用iOS和安卓默认的风格。 modal：iOS独有的使屏幕从底部画出。类似iOS的present效果 headerMode：边缘滑动返回上级页面时动画效果。 float：iOS默认的效果，可以看到一个明显的过渡动画。 screen：滑动过程中，整个页面都会返回。 none：没有动画 cardStyle：自定义设置跳转效果 transitionConfig： 自定义设置滑动返回的配置。 onTransitionStart：当转换动画即将开始时被调用的功能。 onTransitionEnd：当转换动画完成，将被调用的功能。 path：路由中设置的路径的覆盖映射配置。 initialRouteName：设置默认的页面组件，必须是上面已注册的页面组件。 initialRouteParams：初始路由的参数。 path:path属性适用于其他app或浏览器使用url打开本app并进入指定页面。path属性用于声明一个界面路径，例如：【/pages/Home】。此时我们可以在手机浏览器中输入：app名称://pages/Home来启动该App，并进入Home界面。 将此处的 yourApplicationId 替换为你的项目的包名；yourAppKey 替换成你在官网上申请的应用的 AppKey。检查一下 dependencies 中有没有添加 jpush-react-native 及 jcore-react-native 这两个依赖。 TabNavigator 基础用法/属性介绍123456789101112131415161718192021222324252627const MyTab = TabNavigator(&#123; ShiTu: &#123; screen: ShiTu, navigationOptions:&#123; tabBarLabel: &apos;识兔&apos;, tabBarIcon: (&#123;tintColor&#125;) =&gt; ( &lt;Image source=&#123;&#123;uri : &apos;识兔&apos;&#125;&#125; style=&#123;[tabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;, &#125;, &#123; tabBarPosition: &apos;bottom&apos;, swipeEnabled:false, animationEnabled:false, tabBarOptions: &#123; style: &#123; height:49 &#125;, activeBackgroundColor:&apos;white&apos;, activeTintColor:&apos;#4ECBFC&apos;, inactiveBackgroundColor:&apos;white&apos;, inactiveTintColor:&apos;#aaa&apos;, showLabel:false, &#125;&#125;); 屏幕导航配置screen：和导航的功能是一样的，对应界面名称，可以在其他页面通过这个screen传值和跳转。navigationOptions：配置TabNavigator的一些属性 title：标题，会同时设置导航条和标签栏的title，还是不推荐这种方式。 tabBarVisible：是否隐藏标签栏。默认不隐藏(true) tabBarIcon：设置标签栏的图标。需要给每个都设置。 tabBarLabel：设置标签栏的title。推荐这个方式。 tabBarOnPress：设置tabBar的点击事件，内部提供了两个属性，一个方法({ route, index },jumpToIndex)。 beta13新添加的方法，使用方式有些奇葩，如果想要使用，请参照下面的代码 123456 /tabBarOnPress:((&#123; route, index &#125;,jumpToIndex)=&gt;&#123; // console.log(route); // alert(index); // 只有调用jumpToIndex方法之后才会真正的跳转页面。 jumpToIndex(index);&#125;), 标签栏配置tabBarPosition：设置tabbar的位置，iOS默认在底部，安卓默认在顶部。（属性值：’top’，’bottom’） swipeEnabled：是否允许在标签之间进行滑动。 animationEnabled：是否在更改标签时显示动画。 lazy：是否根据需要懒惰呈现标签，而不是提前制作，意思是在app打开的时候将底部标签栏全部加载，默认false,推荐改成true哦。 initialRouteName： 设置默认的页面组件 backBehavior：按 back 键是否跳转到第一个Tab(首页)， none 为不跳转 tabBarOptions：配置标签栏的一些属性 iOS属性 activeTintColor：label和icon的前景色 活跃状态下（选中）。 activeBackgroundColor：label和icon的背景色 活跃状态下（选中） 。 inactiveTintColor：label和icon的前景色 不活跃状态下(未选中)。 inactiveBackgroundColor：label和icon的背景色 不活跃状态下（未选中）。 showLabel：是否显示label，默认开启。 style：tabbar的样式。 labelStyle：label的样式。 安卓属性 activeTintColor：label和icon的前景色 活跃状态下（选中） 。 inactiveTintColor：label和icon的前景色 不活跃状态下(未选中)。 showIcon：是否显示图标，默认关闭。 showLabel：是否显示label，默认开启。 style：tabbar的样式。 labelStyle：label的样式。 upperCaseLabel：是否使标签大写，默认为true。 pressColor：material涟漪效果的颜色（安卓版本需要大于5.0）。 pressOpacity：按压标签的透明度变化（安卓版本需要小于5.0）。 scrollEnabled：是否启用可滚动选项卡。 tabStyle：tab的样式。 indicatorStyle：标签指示器的样式对象（选项卡底部的行）。安卓底部会多出一条线，可以将height设置为0来暂时解决这个问题。 labelStyle：label的样式。 iconStyle：图标的样式。 ps：很多人问我,为什么安卓上的tabbar文字会下移, 是因为安卓比iOS多了一个属性,就是iconStyle,通过设置labelStyle和iconStyle两个样式,外加style的高度,来使效果更佳合理. 跳转1234navigate(&apos;Detail&apos;,&#123; title:&apos;图片详情&apos;, url:item.url, &#125;); Detail：在StackNavigator中注册的页面，需要一一对应，才能跳转到相应的页面 title：在跳转的页面可以通过this.props.navigation.state.params.title获取到这个参数。当然这个参数可以随便填写，都可以通过this.props.navigation.state.params.xxx获取。 回调传参123456navigate(&apos;Detail&apos;,&#123; // 跳转的时候携带一个参数去下个页面 callback: (data)=&gt;&#123; console.log(data); // 打印值为：&apos;回调参数&apos; &#125; &#125;); const {navigate,goBack,state} = this.props.navigation;// 在第二个页面,在goBack之前,将上个页面的方法取到,并回传参数,这样回传的参数会重走render方法state.params.callback(‘回调参数’);goBack(); 自定义项目中基本是没可能用自带的那个导航条的，自带导航条左侧的按钮永远是蓝色的，如果我们需要更改按钮颜色，就需要用到自定义的功能了。123456789101112131415161718192021222324252627282930const StackOptions = (&#123;navigation&#125;) =&gt; &#123; console.log(navigation); let &#123;state,goBack&#125; = navigation; // 用来判断是否隐藏或显示header const visible= state.params.isVisible; let header; if (visible === true)&#123; header = null; &#125; const headerStyle = &#123;backgroundColor:&apos;#4ECBFC&apos;&#125;; const headerTitle = state.params.title; const headerTitleStyle = &#123;fontSize:FONT_SIZE(20),color:&apos;white&apos;,fontWeight:&apos;500&apos;&#125; const headerBackTitle = false; const headerLeft = ( &lt;Button isCustom=&#123;true&#125; customView=&#123; &lt;Icon name=&apos;ios-arrow-back&apos; size=&#123;30&#125; color=&apos;white&apos; style=&#123;&#123;marginLeft:13&#125;&#125; /&gt; &#125; onPress=&#123;()=&gt;&#123;goBack()&#125;&#125; /&gt; ); return &#123;headerStyle,headerTitle,headerTitleStyle,headerBackTitle,headerLeft,header&#125;&#125;; 然后通过下面的方法调用就可以自定制导航了。123456789const MyApp = StackNavigator(&#123; MyTab: &#123; screen: MyTab, &#125;, Detail: &#123; screen: Detail, navigationOptions: (&#123;navigation&#125;) =&gt; StackOptions(&#123;navigation&#125;) &#125;,)&#125;; 在页面中使用的时候，在跳转页面的时候需要传递title参数，才能看到效果哦。 自定义tabbar早上有人问我，tabbar的图标可不可以使用原图，选中状态下可不可以设置其他图标。研究了一下官方文档，发现tabBarIcon除了tintColor还有另一个属性，用来判断选中状态的focused。12345678910111213tabBarIcon: (&#123;tintColor,focused&#125;) =&gt; ( focused ? &lt;Image source=&#123;&#123;uri : &apos;识兔&apos;&#125;&#125; style=&#123;tabBarIcon&#125; /&gt; : &lt;Image source=&#123;&#123;uri : &apos;干货&apos;&#125;&#125; style=&#123;[tabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), 通过判断focused，选中状态下使用识兔图标，未选中状态使用干货图标。如果想使用图标原来的样子，那就将style的tintColor去掉，这样就会显示图标原本的颜色。 再封装12345678910111213141516171819202122232425export const TabOptions = (tabBarTitle,normalImage,selectedImage,navTitle) =&gt; &#123; // console.log(navigation); const tabBarLabel = tabBarTitle; console.log(navTitle); const tabBarIcon = ((&#123;tintColor,focused&#125;)=&gt; &#123; return( focused ? &lt;Image source=&#123;&#123;uri : normalImage&#125;&#125; style=&#123;[TabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; : &lt;Image source=&#123;&#123;uri : selectedImage&#125;&#125; style=&#123;[TabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ) &#125;); const headerTitle = navTitle; const headerTitleStyle = &#123;fontSize:FONT_SIZE(20),color:&apos;white&apos;&#125;; // header的style const headerStyle = &#123;backgroundColor:&apos;#4ECBFC&apos;&#125;; return &#123;tabBarLabel,tabBarIcon,headerTitle,headerTitleStyle,headerStyle&#125;;&#125;; 在static中使用this方法我之前文章中是将navaigationOptions的方法写在了app.js中，没有在页面中通过static navaigationOptions来初始化页面，这段时间刚好有人问，所以在这里就写一下该怎么弄。 ####首先需要在componentDidMount(){}中动态的添加点击事件12345678属性给paramscomponentDidMount()&#123; this.props.navigation.setParams(&#123; title:&apos;自定义Header&apos;, navigatePress:this.navigatePress &#125;)&#125; 1234navigatePress = () =&gt; &#123; alert(&apos;点击headerRight&apos;); console.log(this.props.navigation);&#125; 接下来就可以通过params方法来获取点击事件了12345678static navigationOptions = (&#123; navigation, screenProps &#125;) =&gt; (&#123; title: navigation.state.params?navigation.state.params.title:null, headerRight:( &lt;Text onPress=&#123;navigation.state.params?navigation.state.params.navigatePress:null&#125;&gt; 返回 &lt;/Text&gt; )&#125;); 让安卓实现push动画之前我群里的讨论怎么让安卓实现类似iOS的push动画，后来翻看官方issues的时候，真的发现了实现push动画的代码，在这里共享下12345678910// 先引入这个方法import CardStackStyleInterpolator from &apos;react-navigation/src/views/CardStackStyleInterpolator&apos;;// 在StackNavigator配置headerMode的地方，使用transitionConfig添加&#123; headerMode: &apos;screen&apos;, transitionConfig:()=&gt;(&#123; screenInterpolator:CardStackStyleInterpolator.forHorizontal, &#125;)&#125; 关于goBack返回指定页面react-navigation是提供了goBack()到指定页面的方法的，那就是在goBack()中添加一个参数，但当你使用goBack(‘Main’)的时候，你会发现并没有跳转，原因是react-navigation默认goBack()中的参数是系统随机分配的key，而不是手动设置的routeName，而方法内部又没有提供可以获得key的方法，所以这里只能通过修改源码将key换成routeName了。 下面的内容直接引用了hello老文的内容12345把项目/node_modules/react-navigation/src/routers/StackRouter.js文件里的 const backRoute = state.routes.find((route: *) =&gt; route.key === action.key); 改成 const backRoute = state.routes.find(route =&gt; route.routeName === action.key);但不是很完美, 这里的component要填想返回的组件的前一个组件的routeName, 比如你的栈里顺序是home1, home2, home3, home4, 在home4里要返回home2, 使用this.props.navigation.goBack(&apos;home3&apos;);; 并且又会带出一个问题: goBack()方法没反应了, 必须加个null进去, 写成goBack(null)... 关于goBack返回指定页面的修改完善版1234567891011121314151617181920212223242526if (action.type === NavigationActions.BACK) &#123; let backRouteIndex = null; if (action.key) &#123; const backRoute = state.routes.find( /* $FlowFixMe */ /* 修改源码 */ route =&gt; route.routeName === action.key /* (route: *) =&gt; route.key === action.key */ ); /* $FlowFixMe */ console.log(&apos;backRoute =====&apos;,backRoute); backRouteIndex = state.routes.indexOf(backRoute); console.log(&apos;backRoute =====&apos;,backRouteIndex); &#125; if (backRouteIndex == null) &#123; return StateUtils.pop(state); &#125; if (backRouteIndex &gt;= 0) &#123; return &#123; ...state, routes: state.routes.slice(0, backRouteIndex+1), index: backRouteIndex - 1 + 1, &#125;; &#125; &#125; 感谢群友conan的贡献，将源码改成上面的样子，就可以使用goBack()返回指定页面了，这样的优点不言而喻，但缺点就是每次调用goBack()，如果只是简单的返回上一页需要加上null参数，类似这样goBack(null)， 如果这样修改，在滑动返回的时候，会有很大几率让项目卡死，请注意使用该方法，推荐集成redux。 关于快速点击会导致多次跳转的问题解决办法感谢群友编程大叔的贡献，如果想解决快速点击跳转的问题，需要修改部分源码。 修改react-navigation目录下，scr文件夹中的addNavigationHelpers.js文件，可以直接替换成下面的文本，也可以查看原版链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export default function&lt;S: *&gt;(navigation: NavigationProp&lt;S, NavigationAction&gt;) &#123; // 添加点击判断 let debounce = true; return &#123; ...navigation, goBack: (key?: ?string): boolean =&gt; navigation.dispatch( NavigationActions.back(&#123; key: key === undefined ? navigation.state.key : key, &#125;), ), navigate: (routeName: string, params?: NavigationParams, action?: NavigationAction,): boolean =&gt; &#123; if (debounce) &#123; debounce = false; navigation.dispatch( NavigationActions.navigate(&#123; routeName, params, action, &#125;), ); setTimeout( () =&gt; &#123; debounce = true; &#125;, 500, ); return true; &#125; return false; &#125;, /** * For updating current route params. For example the nav bar title and * buttons are based on the route params. * This means `setParams` can be used to update nav bar for example. */ setParams: (params: NavigationParams): boolean =&gt; navigation.dispatch( NavigationActions.setParams(&#123; params, key: navigation.state.key, &#125;), ), &#125;;&#125; 安卓上，使用TextInput的时候会让TabBar顶起来的解决办法最简单的解决办法就是在android目录中，添加一句话 目录：android/app/src/main/AndroidManifest.xml中，添加 android:windowSoftInputMode=”stateAlwaysHidden|adjustPan|adjustResize” ps：在iOS下如果想一劳永逸的解决键盘问题，请使用IQKeyBoardManager。 总结react-navigation才开始用的时候感觉是复杂的，但用的多了，会感觉真的很不错。如果在文章中有什么不懂的问题，欢迎在评论区评论，也可以发私信，加QQ群397885169一起讨论哦。 本编文章以同步到博客：传送门文章转载于挂着铃铛的兔点击查看更多文章","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React-Native Android真机测试 -unable to load script from assets 'index.android bundle'...","slug":"React-Native Android真机测试 -unable to load script from assets 'index.android bundle'...","date":"2017-08-27T16:00:00.000Z","updated":"2017-12-22T07:20:54.000Z","comments":true,"path":"2017/08/28/React-Native Android真机测试 -unable to load script from assets 'index.android bundle'.../","link":"","permalink":"https://zhangyanlf.top/2017/08/28/React-Native Android真机测试 -unable to load script from assets 'index.android bundle'.../","excerpt":"","text":"在Android 华为手机上运行React_Native工程时出现了如下错误，做以记录： 报错：unable to load script from assets ‘index.android bundle’ ,make sure your bundle is packaged correctly or youu’re runing a packager server 解决报错的方法： 第一步：在Android/app/src/main目录下创建一个空的assets文件夹， 第二步：进入项目根目录执行下面代码：1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/ 运行完毕后assets文件夹下会多出index.android.bundle和index.android.bundle.meta两个文件 第三步：重新运行程序完美解决。 总结：index.android.bundle是用来调用原生控件的js脚本，每次当改变了 index.android.js，都需要使用上面的代码片段，来及时的更新index.android.bundle，然后打包才可以把新的index.android.js应用上，所以当没有index.android.bundle文件时，React-Native 项目是无法运行的。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React-Native 项目打包(iOS/Android)","slug":"React-Native 项目打包(iOS_Android)","date":"2017-08-02T16:00:00.000Z","updated":"2017-12-22T07:21:38.000Z","comments":true,"path":"2017/08/03/React-Native 项目打包(iOS_Android)/","link":"","permalink":"https://zhangyanlf.top/2017/08/03/React-Native 项目打包(iOS_Android)/","excerpt":"","text":"1. Android 打包 第一步:生成Android签名证书 签名APK需要一个证书用于为APP签名，生成签名证书可以Android Studio以可视化的方式生成，也可以使用终端采用命令行的方式生成。 第二步：设置gradle变量 1.将你的签名证书copy到 android/app目录下。2.编辑~/.gradle/gradle. properties或../android/gradle.properties(一个是全局gradle.properties，一个是项目中的gradle.properties，大家可以根据需要进行修改) ，加入如下代码：1234MYAPP_RELEASE_STORE_FILE=your keystore filename MYAPP_RELEASE_KEY_ALIAS=your keystore alias MYAPP_RELEASE_STORE_PASSWORD=***** MYAPP_RELEASE_KEY_PASSWORD=***** 提示：用正确的证书密码、alias以及key密码替换掉 *。 第三步：在gradle配置文件中添加签名配置 编辑 android/app/build.gradle文件添加如下代码：1234567891011121314151617181920... android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125; &#125; ... 第四步：签名打包APK terminal进入项目下的android目录，运行如下代码：./gradlew assembleRelease 签名打包成功后你会在 “android/app/build/outputs/apk/”目录下看到签名成功后的app-release.apk文件。 提示：如果你需要对apk进行混淆打包 编辑android/app/build.gradle：。 1234/** * Run Proguard to shrink the Java bytecode in release builds. */ def enableProguardInReleaseBuilds = true 2.iOS打包 第一步：rn项目的ios工程文件夹创建bundle文件夹，然后生成jsbundle 进入rn项目的ios工程文件夹，找到和rn项目同名的文件件，打开AppDelegate.m文件，将这一行注释掉(为了方便真机和模拟器间的切换，尽量注释)： 12jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; 新加一行： 1jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;index.ios&quot; withExtension:@&quot;jsbundle&quot;]; 如果需要切换回模拟器调试，只需要将新加这行注释掉，并恢复原代码即可。 新加这行代码意思就是告诉native rn代码的入口，我们会在下一步生成这个jsbundle。 第二步：打开终端，进入你的rn工程，在根目录下执行bundle命令 1react-native bundle --entry-file ./index.ios.js --bundle-output ./ios/bundle/index.ios.jsbundle --platform ios --assets-dest ./ios/bundle --dev false 参数说明： -entry-file 指定入口文件 因为要打包ios平台，所以指定为rn项目的index.ios.js作为入口 –bundle-output 指定输出的jsbundle文件路径和文件名 指定到rn项目的ios工程文件夹下，记得一定要先创建bundle文件夹，不然终端会报文件夹找不到的错误 –platform 指定平台类型 –assets-dest 指定资源文件夹路径 assets文件夹的路径，包含图片、node模块等资源 –dev 是否为开发模式 如果设置为false，不会产生警告，并且bundle会被压缩还有其他命令，比如：transformer、prepack、bundle-encoding等，可以到官网查看具体介绍。 完成后bundle生成完成后，终端会有类似提示： 第三步：用xcode Open another project打开rn项目的ios工程文件夹 配置网络访问白名单： 打开info.plist 设置应用图标和启动图: iOS应用中没有图标，打包会报错。 然后，就可以进行打包，流程和原生iOS打包流程一样，（首先的配置证书）iOS打包流程可以参照博客中的打包上线流程：传送门 注：Ad Hoc 和 App Store 打包过程基本一样，区别在于生成证书时需选择相对应的证书。。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React-Native集成JPush-react-native及应用设置Tags、Alias（iOS/Android）","slug":"React-Native集成JPush-react-native及应用设置Tags、Alias","date":"2017-07-30T16:00:00.000Z","updated":"2017-12-22T07:20:30.000Z","comments":true,"path":"2017/07/31/React-Native集成JPush-react-native及应用设置Tags、Alias/","link":"","permalink":"https://zhangyanlf.top/2017/07/31/React-Native集成JPush-react-native及应用设置Tags、Alias/","excerpt":"","text":"最近项目中用到推送功能，且项目是以React-Native框架实现iOS、Android跨平台开发，自然而然就选择了极光实现推送功能，由于以前是iOS开发对Android了解的不很很深，在集成和设置别名等问题上也遇到些坑，现在就把集成步骤及遇到的问题分享出来，仅供大家参考，有什么问题也可以留言一起探讨： 安装 cd到项目根目录 执行 npm install jpush-react-native –save npm install jcore-react-native –save ## jpush-react-native 1.4.2 版本以后需要同时安装 jcore-react-native 配置 配置包括两个步骤，自动配置和手动操作。 1.自动配置：以下命令均在你的 React Native 项目目录下运行，自动配置后仍需手动配置一部分） 执行脚本 npm run configureJPush yourAppKey yourModuleNamemodule name 指的是你 Android 项目中的模块名字(对 iOS 没有影响，不填写的话默认值为 app，会影响到查找 AndroidManifest 问题，如果没找到 AndroidManifest，则需要手动修改，参考下面的 AndroidManifest 配置相关说明) eg:npm run configureJPush 48f30d0b04d9bc4f5ad7de53 app 执行脚本react-native link 2.手动配置部分iOS 手动操作部分 （4步） 在React-Native工程中node_modules -&gt; push-react-native -&gt; ios - &gt; RCTJPushModule -&gt; RCTJPushModule.xcodeproj 拖入iOS工程Libraries中并添加： 在 iOS 工程中设置 TARGETS-&gt; BUILD Phases -&gt; LinkBinary with Libraries 找到 UserNotifications.framework 把 status 设为 optional 在 iOS 工程中如果找不到头文件可能要在 TARGETS-&gt; BUILD SETTINGS -&gt; Search Paths -&gt; Header Search Paths 添加如下路径$(SRCROOT)/../node_modules/jpush-react-native/ios/RCTJPushModule/RCTJPushModule 在 xcode8 之后需要点开推送选项： TARGETS -&gt; Capabilities -&gt; Push Notification 设为 on 状态 Android 手动操作部分 修改 app 下的 build.gradle 配置： react native project/android/app/build.gradle1234567891011121314151617android &#123; defaultConfig &#123; applicationId &quot;yourApplicationId&quot; ... manifestPlaceholders = [ JPUSH_APPKEY: &quot;yourAppKey&quot;, //在此替换你的APPKey APP_CHANNEL: &quot;developer-default&quot; //应用渠道号 ] &#125;&#125;...dependencies &#123; compile fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) compile project(&apos;:jpush-react-native&apos;) // 添加 jpush 依赖 compile project(&apos;:jcore-react-native&apos;) // 添加 jcore 依赖 compile &quot;com.facebook.react:react-native:+&quot; // From node_modules&#125; 将此处的 yourApplicationId 替换为你的项目的包名；yourAppKey 替换成你在官网上申请的应用的 AppKey。检查一下 dependencies 中有没有添加 jpush-react-native 及 jcore-react-native 这两个依赖。 react native project/android/app/build.gradle1234567...dependencies &#123; compile fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) compile project(&apos;:jpush-react-native&apos;) // 添加 jpush 依赖 compile project(&apos;:jcore-react-native&apos;) // 添加 jcore 依赖 compile &quot;com.facebook.react:react-native:+&quot; // From node_modules&#125; 检查 android 项目下的 settings.gradle 配置有没有包含以下内容： settings.gradle123include &apos;:app&apos;, &apos;:jpush-react-native&apos;, &apos;:jcore-react-native&apos;project(&apos;:jpush-react-native&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/jpush-react-native/android&apos;)project(&apos;:jcore-react-native&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/jcore-react-native/android&apos;) 检查一下 app 下的 AndroidManifest 配置，有没有增加 部分。 react native project/android/app/AndroidManifest.xml1234567&lt;application ... &lt;!-- Required . Enable it you can get statistics data with channel --&gt; &lt;meta-data android:name=&quot;JPUSH_CHANNEL&quot; android:value=&quot;$&#123;APP_CHANNEL&#125;&quot;/&gt; &lt;meta-data android:name=&quot;JPUSH_APPKEY&quot; android:value=&quot;$&#123;JPUSH_APPKEY&#125;&quot;/&gt; &lt;/application&gt; 然后重新 sync 一下项目，应该能看到 jpush-react-native 以及 jcore-react-native 作为 android Library 项目导进来了 加入 JPushPackage，有参数！ RN 0.29.0 以下版本打开 app 下的 MainActivity，在 ReactInstanceManager 的 build 方法中加入 JPushPackage： app/MainActivity.java RN 0.29.0 以上版本打开 app 下的 MainApplication.java 文件，然后加入 JPushPackage,也可以参考官方Demo 123456789101112131415161718192021// 设置为 true 将不弹出 toastprivate boolean SHUTDOWN_TOAST = false;// 设置为 true 将不打印 logprivate boolean SHUTDOWN_LOG = false;private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new JPushPackage(SHUTDOWN_TOAST, SHUTDOWN_LOG) ); &#125;&#125;; 到这里Push-react-native就已将集成到iOS和Android工程中了，然后就可以去极光后台发送通知，查看推送消息（注：如果你是Android工程师，在iOS集成后还需将推送证书上传到极光后台认证，认证通过后即可发送推送通知！！！） 上面集成就告一段落了，下面就是在React-Native项目中给iOS和Android 设置Tags和 Alias了： Note: In Android, you must call initPush first, iOS doesn’t need.在设置tags和Alias前 Android项目首先需要在MainActivity中 initPush ，iOS不需要操作：12345678910111213141516171819componentDidMount()&#123; console.log(&apos;componentDidMount&apos;); JPushModule.setTags([this.state.tag], () =&gt; &#123; // Alert.alert(&apos;成功&apos;, &apos;tags 成功&apos;,[&#123;text: &apos;OK&apos;&#125;])； console.log(&apos;success set tag&apos;); &#125;, () =&gt; &#123; // Alert.alert(&apos;失败&apos;,&apos;设置alias 失败&apos;,[&#123;text:&apos;fail&apos;&#125;]); console.log(&apos;fail set tag&apos;); &#125;); JPushModule.setAlias(&apos;James&apos;, () =&gt; &#123; Alert.alert(&apos;成功&apos;, &apos;设置alias 成功&apos;,[&#123;text: &apos;OK&apos;&#125;]); console.log(&apos;成功&apos;); &#125;, () =&gt; &#123; Alert.alert(&apos;失败&apos;,&apos;设置alias 失败&apos;,[&#123;text:&apos;fail&apos;&#125;]); console.log(&apos;失败&apos;); &#125;); &#125; 注:在设置Tags时要传一个数组过去！！！","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React Native图表插件react-native-charts-wrapper集成教程","slug":"React Native图表插件react-native-charts-wrapper集成教程","date":"2017-05-22T16:00:00.000Z","updated":"2017-12-22T07:22:24.000Z","comments":true,"path":"2017/05/23/React Native图表插件react-native-charts-wrapper集成教程/","link":"","permalink":"https://zhangyanlf.top/2017/05/23/React Native图表插件react-native-charts-wrapper集成教程/","excerpt":"","text":"最近公司项目要用到图标显示，在网上找了好多天找到react-native-charts-wrapper，这款第三方图形很全，功能也很强大，就和大家一起分享下使用心得:(iOS端)，好了，话不多说，接下来开始一步一步集成图表插件react-native-charts-wrapper：react-native-charts-wrapper GitHub地址 1.新建一个项目 出现下面界面时，说明项目已经创建成功： 2.安装react-native-charts-wrapper （注意：一定要在根目录下安装）进入项目根目录执行 npm install –save react-native-charts-wrapper 3.把该目录下ZylCharts/node_modules/react-native-charts-wrapper/ReactNativeCharts的整个ReactNativeCharts文件夹,拖入到项目中 拖入后： 4.Add Bridge File：因为后面会用到SwiftyJSONandiOS Charts,这是用Swift写的，所以我们需要一个桥接文件，方法如下：新建一个工程名-Bridging-Header.h头文件(注意，必须是工程名开头！！！)： 5.接下来就需要使用我前面说的SwiftyJSONandiOS Charts这里已经下好了，链接地址： https://pan.baidu.com/s/1o7Y3oRg 密码: 32j9 下载下拉解压后，拖到iOS项目根目录下： 6.把刚刚的两个文件夹中的SwiftyJSON.xcodeproj and Charts.xcodeproj拖到工程的libraries中： 7.接下来-&gt; Build Phases -&gt;Link Binary With Libraries添加SwiftyJSON.frameworkand Charts.framework. 8.添加SwiftyJSON.frameworkand Charts.framework 到 Embedded Binaries. 然后：Edit -&gt; Convert -&gt; To Current Swift Syntax… 完成之后点击save。 接下来在桥文件里面添加： 9.到这里配置已经完成，花键+b变一下程序：遇到错误：1.Command /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1 2.Command /usr/bin/ditto failed with exit code 1原因：运行从网下下载的swift项目的时候，基本上都会出现这个错误。意思是找不到项目文件。解决方法：直接忽略，运行程序就好。 这样就配置好了，项目中的报错也就解决了！ ##下面就根据react-native-charts-wrapper文档示例代码，写个柱形图。 index.ios.js: 1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;import ZylChartScreen from &apos;./ZylChartScreen&apos;;export default class ZylCharts extends Component &#123; render() &#123; return ( &lt;ZylChartScreen /&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;ZylCharts&apos;, () =&gt; ZylCharts); ZylChartScreen.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Created by zhangyanlf on 17/5/23. */import React from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, processColor&#125; from &apos;react-native&apos;;import &#123;BarChart&#125; from &apos;react-native-charts-wrapper&apos;;class ZylBarChartScreen extends React.Component &#123; constructor() &#123; super(); this.state = &#123; legend: &#123; enabled: true, textSize: 14, form: &apos;SQUARE&apos;, formSize: 14, xEntrySpace: 10, yEntrySpace: 5, formToTextSpace: 5, wordWrapEnabled: true, maxSizePercent: 0.5 &#125;, data: &#123; dataSets: [&#123; values: [&#123;y: 100&#125;, &#123;y: 105&#125;, &#123;y: 102&#125;, &#123;y: 110&#125;, &#123;y: 114&#125;, &#123;y: 109&#125;, &#123;y: 105&#125;, &#123;y: 99&#125;, &#123;y: 95&#125;], label: &apos;Bar dataSet&apos;, config: &#123; color: processColor(&apos;teal&apos;), barSpacePercent: 40, barShadowColor: processColor(&apos;lightgrey&apos;), highlightAlpha: 90, highlightColor: processColor(&apos;red&apos;), &#125; &#125;], &#125;, xAxis: &#123; valueFormatter: [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;], granularityEnabled: true, granularity : 1, &#125; &#125;; &#125; handleSelect(event) &#123; let entry = event.nativeEvent if (entry == null) &#123; this.setState(&#123;...this.state, selectedEntry: null&#125;) &#125; else &#123; this.setState(&#123;...this.state, selectedEntry: JSON.stringify(entry)&#125;) &#125; &#125; render() &#123; return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;View style=&#123;&#123;height:80,marginTop: 15&#125;&#125;&gt; &lt;Text style=&#123;styles.entryStyle&#125;&gt; selected entry&lt;/Text&gt; &lt;Text style=&#123;styles.entryStyle&#125;&gt; &#123;this.state.selectedEntry&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;BarChart style=&#123;styles.chart&#125; data=&#123;this.state.data&#125; xAxis=&#123;this.state.xAxis&#125; animation=&#123;&#123;durationX: 2000&#125;&#125; legend=&#123;this.state.legend&#125; gridBackgroundColor=&#123;processColor(&apos;#ffffff&apos;)&#125; drawBarShadow=&#123;false&#125; drawValueAboveBar=&#123;true&#125; drawHighlightArrow=&#123;true&#125; onSelect=&#123;this.handleSelect.bind(this)&#125; /&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &apos;#F5FCFF&apos;, &#125;, chart: &#123; flex: 1 &#125;, entryStyle: &#123; color: &apos;orange&apos;, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos; &#125;&#125;);export default ZylBarChartScreen; 效果图： ok，就先写一个柱形图，其他的以后有时间再继续学习！！!","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React Native 封装Tabbar","slug":"RN封装Tabbar","date":"2017-05-10T16:00:00.000Z","updated":"2017-12-22T07:23:59.000Z","comments":true,"path":"2017/05/11/RN封装Tabbar/","link":"","permalink":"https://zhangyanlf.top/2017/05/11/RN封装Tabbar/","excerpt":"","text":"做个封装的Tabbar为了以后方便运用，同时也希望给初学者提供一点小小的帮助，闲话不多说了,开始工程！（兼容iOS及Android）。1.初始化项目导入图片资源，iOS直接导入Images.xcassets即可，Android导入src/mian/res下面，与Android导入资源方法一致。2.整合项目，创建Class文件夹，将所要编写的js文件全部放在里面方便管理及后期项目维护。###整合后index.ios.js及index.android.js作为程序的入口，Class中创建packageTabbar.js文件， 如下图：注意：导入外部组件时首字母必须大写不然会报错。 ok！！下面就开始一步一步的封装Tabbar：第一步：进入RN项目目录执行npm install react-native-tab-navigator –save导入库 传送门 学习react-native-tab-navigator具体使用； 第二步：进入packagetabbar.js导入外部组件 12/**-导入外部组件-**/import TabNavigator from &apos;react-native-tab-navigator&apos;; 第三部：编写Tabbar代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/**----导入外部组件-----**/import TabNavigator from &apos;react-native-tab-navigator&apos;;var Home = require(&apos;../Home/ZylHome&apos;);var Mine = require(&apos;../Mine/ZylMine&apos;);var Shop = require(&apos;../Shop/ZylShop&apos;);var More = require(&apos;../More/ZylMore&apos;);var Main = React.createClass(&#123; //初始化函数（变量是可以改变，从当状态机的角色） getInitialState()&#123; return&#123; selectedTab:&apos;home&apos; //默认是第一个 &#125; &#125;, render() &#123; return ( &lt;TabNavigator&gt; &#123;/*--首页--*/&#125; &#123;this.renderTabBarItem(&apos;首页&apos;, &apos;icon_tabbar_homepage&apos;, &apos;icon_tabbar_homepage_selected&apos;, &apos;home&apos;, &apos;首页&apos;, Home)&#125; &#123;/*--商家--*/&#125; &#123;this.renderTabBarItem(&apos;商家&apos;, &apos;icon_tabbar_merchant_normal&apos;, &apos;icon_tabbar_merchant_selected&apos;, &apos;shop&apos;, &apos;商家&apos;, Shop)&#125; &#123;/*--我的--*/&#125; &#123;this.renderTabBarItem(&apos;我的&apos;, &apos;icon_tabbar_mine&apos;, &apos;icon_tabbar_mine_selected&apos;, &apos;mine&apos;, &apos;我的&apos;, Mine)&#125; &#123;/*--更多--*/&#125; &#123;this.renderTabBarItem(&apos;更多&apos;, &apos;icon_tabbar_misc&apos;, &apos;icon_tabbar_misc_selected&apos;, &apos;more&apos;, &apos;更多&apos;, More)&#125; &lt;/TabNavigator&gt; ); &#125;, //每一个TabBarItem renderTabBarItem(title, iconName, selectedIconName, selectedTab, componentName, component, badgeText )&#123; return( &lt;TabNavigator.Item title=&#123;title&#125; renderIcon=&#123;() =&gt; &lt;Image source=&#123;&#123;uri: iconName&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image source=&#123;&#123;uri: selectedIconName&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125; //选中图标 onPress=&#123;() =&gt;&#123;this.setState(&#123;selectedTab:selectedTab&#125;)&#125;&#125; selected=&#123;this.state.selectedTab === selectedTab&#125; selectedTitleStyle=&#123;styles.selectedTitleStyle&#125; badgeText=&#123;badgeText&#125; &gt; &lt;Navigator initialRoute=&#123;&#123;name: componentName,component: component&#125;&#125; configureScene=&#123;() =&gt; &#123; return Navigator.SceneConfigs.PushFromRight; &#125;&#125; renderScene=&#123;(route,navigator) =&gt; &#123; let Component = route.component; return &lt;Component &#123;...route.passProps&#125; navigator=&#123;navigator&#125;/&gt; &#125;&#125; /&gt; &lt;/TabNavigator.Item&gt; ) &#125;&#125;);const styles = StyleSheet.create(&#123; iconStyle: &#123; width: Platform.OS === &apos;ios&apos; ? 30 :25, height: Platform.OS === &apos;ios&apos; ? 30 :25 &#125;, selectedTitleStyle: &#123; color: &apos;orange&apos; &#125;&#125;); 第四部：运行工程，查看结果，针对iOS及Android页面细节做出调整（查看上面代码Platform–判断系统） 效果图如下： GitHub地址","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]},{"title":"React Native 搭建开发环境","slug":"React native搭建环境","date":"2017-04-28T16:00:00.000Z","updated":"2017-12-22T07:22:51.000Z","comments":true,"path":"2017/04/29/React native搭建环境/","link":"","permalink":"https://zhangyanlf.top/2017/04/29/React native搭建环境/","excerpt":"","text":"刚搭好博客，一时半会儿也不知道些什么，想想自己在接触RN时遇到的坑，所以就从第一步搭建RN开发环境说起，能让刚接触RN的伙伴们少走一些弯路。 本篇文章是基于iOS 在macOS上搭建RN环境 安装##必须的软件 HomeBrew Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。 /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复： sudo chown -R whoami /usr/local Node 使用Homebrew来安装Node.jsReact Native目前需要NodeJS 5.0或更高版本。本文发布时Homebrew默认安装的是最新版本，一般都满足要求。 brew install node 安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！ npm config set registry https://registry.npm.taobao.org –globalnpm config set disturl https://npm.taobao.org/dist –global Yarn、React Native的命令行工具（react-native-cli）Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源 yarn config set registry https://registry.npm.taobao.org –globalyarn config set disturl https://npm.taobao.org/dist –global 如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权： sudo chown -R whoami /usr/local ###XcodeReact Native目前需要Xcode 8.0 或更高版本。你可以通过App Store或是到Apple开发者官网上下载。这一步骤会同时安装Xcode IDE和Xcode的命令行工具。 虽然一般来说命令行工具都是默认安装了，但你最好还是启动Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode的命令行工具中也包含一些必须的工具，比如git等。 推荐安装的工具WatchmanWatchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。 brew install watchman 译注：我推荐使用WebStorm写RN，因为别的用的都不是很爽，代码提示也不怎么友好。下面会给大家说明如何使用代码提示插件。 测试安装 react-native init Hello worldcd Hello worldreact-native run-ios WebStorm代码提示插件 https://github.com/virtoolswebplayer/ReactNative-LiveTemplate.git Github上说的非常清楚，有如何导入文件，导入完成后记得重启，代码提示就搞定了。赶紧去体验体验，让你的手指飞舞起来开吧。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://zhangyanlf.top/tags/React-Native/"}]}]}